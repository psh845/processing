
<!-- saved from url=(0113)http://www.scratchapixel.com/code.php?id=35&origin=/lessons/advanced-rendering/bezier-curve-rendering-utah-teapot -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
<!-- title should be set at this point in page.php -->
<title>B&#233;zier Curves and Surfaces: the Utah Teapot (source code)</title>

<meta name="author" content="Scratchapixel">
<meta name="copyright" content="&#169; 2009-2015 Scratchapixel">
<meta name="keywords" content="B&#233;zier Curves and Surfaces: the Utah Teapot, source code">
<meta name="date" content="">

<link rel="stylesheet" type="text/css" href="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/scratchapixel2.css">
<link rel="stylesheet" type="text/css" href="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/page.css">
<link href="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/css" rel="stylesheet" type="text/css">
<link href="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/css(1)" rel="stylesheet" type="text/css">

<!-- using the material icons from Google http://google.github.io/material-design-icons/ -->
<link rel="stylesheet" href="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/icon">

<script id="twitter-wjs" src="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/widgets.js"></script><script id="facebook-jssdk" src="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/sdk.js"></script><script async="" src="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/analytics.js"></script><script type="text/x-mathjax-config;executed=true">
  MathJax.Hub.Config(
	{tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, 
	displayAlign: "left",
	displayIndent: "1em",
	"HTML-CSS": { scale: 90 },
	jax: ["input/TeX","input/MathML","input/AsciiMath","output/HTML-CSS","output/NativeMML"],
	extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js"],
	TeX: {
		extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
	}
	});

</script>
<script type="text/javascript" src="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/MathJax.js">
</script>
<script type="text/javascript" src="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/scratchapixelSDK.js">
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42771397-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- 
https://developers.facebook.com/docs/plugins/share-button/
Include the JavaScript SDK on your page once, ideally right after the opening <body> tag.
-->

<script>
  window.fbAsyncInit = function() {
	FB.init({
	  appId      : '1535346446701691',
	  xfbml      : true,
	  version    : 'v2.1'
	});
  };

  (function(d, s, id){
	 var js, fjs = d.getElementsByTagName(s)[0];
	 if (d.getElementById(id)) {return;}
	 js = d.createElement(s); js.id = id;
	 js.src = "//connect.facebook.net/en_US/sdk.js";
	 fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<script>
	!function(d,s,id) {
		var js,fjs=d.getElementsByTagName(s)[0];
		if(!d.getElementById(id)) {
			js=d.createElement(s);js.id=id;
			js.src="https://platform.twitter.com/widgets.js";
			fjs.parentNode.insertBefore(js,fjs);
		}
	}(document,"script","twitter-wjs");
</script>

<link rel="stylesheet" type="text/css" href="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/responsive.css">
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}.fb_link img{border:none}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_reset .fb_dialog_legacy{overflow:visible}.fb_dialog_advanced{padding:10px;-moz-border-radius:8px;-webkit-border-radius:8px;border-radius:8px}.fb_dialog_content{background:#fff;color:#333}.fb_dialog_close_icon{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;_background-image:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif);cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{top:5px;left:5px;right:auto}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent;_background-image:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}.fb_dialog_close_icon:active{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent;_background-image:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}.fb_dialog_loader{background-color:#f6f7f8;border:1px solid #606060;font-size:24px;padding:20px}.fb_dialog_top_left,.fb_dialog_top_right,.fb_dialog_bottom_left,.fb_dialog_bottom_right{height:10px;width:10px;overflow:hidden;position:absolute}.fb_dialog_top_left{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 0;left:-10px;top:-10px}.fb_dialog_top_right{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -10px;right:-10px;top:-10px}.fb_dialog_bottom_left{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -20px;bottom:-10px;left:-10px}.fb_dialog_bottom_right{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -30px;right:-10px;bottom:-10px}.fb_dialog_vert_left,.fb_dialog_vert_right,.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{position:absolute;background:#525252;filter:alpha(opacity=70);opacity:.7}.fb_dialog_vert_left,.fb_dialog_vert_right{width:10px;height:100%}.fb_dialog_vert_left{margin-left:-10px}.fb_dialog_vert_right{right:0;margin-right:-10px}.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{width:100%;height:10px}.fb_dialog_horiz_top{margin-top:-10px}.fb_dialog_horiz_bottom{bottom:0;margin-bottom:-10px}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #3a5795;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{-webkit-transform:none;height:100%;margin:0;overflow:visible;position:absolute;top:-10000px;left:0;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{width:auto;height:auto;min-height:initial;min-width:initial;background:none}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{color:#fff;display:block;padding-top:20px;clear:both;font-size:18px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .45);position:absolute;bottom:0;left:0;right:0;top:0;width:100%;min-height:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_content .dialog_header{-webkit-box-shadow:white 0 1px 1px -1px inset;background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#738ABA), to(#2C4987));border-bottom:1px solid;border-color:#1d4088;color:#fff;font:14px Helvetica, sans-serif;font-weight:bold;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{-webkit-font-smoothing:subpixel-antialiased;height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#4966A6), color-stop(.5, #355492), to(#2A4887));border:1px solid #2f477a;-webkit-background-clip:padding-box;-webkit-border-radius:3px;-webkit-box-shadow:rgba(0, 0, 0, .117188) 0 1px 1px inset, rgba(255, 255, 255, .167969) 0 1px 0;display:inline-block;margin-top:3px;max-width:85px;line-height:18px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{border:none;background:none;color:#fff;font:12px Helvetica, sans-serif;font-weight:bold;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #555;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f6f7f8;border:1px solid #555;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/yD/r/t-wz8gw1xG1.png);background-repeat:no-repeat;background-position:50% 50%;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_hide_iframes iframe{position:relative;left:-10000px}.fb_iframe_widget_loader{position:relative;display:inline-block}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}.fb_iframe_widget_loader iframe{min-height:32px;z-index:2;zoom:1}.fb_iframe_widget_loader .FB_Loader{background:url(https://fbstatic-a.akamaihd.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat;height:32px;width:32px;margin-left:-16px;position:absolute;left:50%;z-index:4}</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>

<body onload="onload();"><div id="MathJax_Message" style="display: none;"></div>
<div id="sap-root"></div><!-- that's needed by scratchapixel see onload() -->
<div id="fb-root" class=" fb_reset"><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div><iframe name="fb_xdm_frame_http" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" id="fb_xdm_frame_http" aria-hidden="true" title="Facebook Cross Domain Communication Frame" tabindex="-1" src="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/xd_arbiter.html" style="border: none;"></iframe><iframe name="fb_xdm_frame_https" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" id="fb_xdm_frame_https" aria-hidden="true" title="Facebook Cross Domain Communication Frame" tabindex="-1" src="./B&#233;zier Curves and Surfaces_ the Utah Teapot (source code)_files/xd_arbiter(1).html" style="border: none;"></iframe></div></div><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div></div></div></div> <!-- that's required by FB -->
<div class="header-table">
<a style="text-decoration: none; color: rgb(250, 250, 250);" href="http://www.scratchapixel.com/index.php">
<div class="header-center-column">

<!--
<div style='vertical-align: middle; width: 40px; padding: 0px; margin: 0px; border: 1px none orange; display: table-cell;'>
<img style='padding: 0px; margin: 0px; width: 100%;' src='/images/design/logo_scratchapixel2015.png?'/>
</div>
-->
<div style="margin: 10px 0px; width: 100%; vertical-align: middle; padding: 0px; border: 1px none orange; display: table;">
	<div style="display:table-row;">
		<p style="display: table-cell; font-size: 24px; font-weight: 800;">Scratchapixel 2.0</p>
	</div>
	<div style="display:table-row;">
		<p style="display: table-cell; font-size: 16px; font-weight: 400;">Learn Computer Graphics Programming from Scratch</p>
	</div>
</div>

</div></a></div><!-- end of header table -->

<div class="page-content">
<article><div class="lesson-title" style="padding: 0px; margin: 20px 0px 10px 0px;"><a href="http://www.scratchapixel.com/lessons/advanced-rendering/bezier-curve-rendering-utah-teapot">B&#233;zier Curves and Surfaces: the Utah Teapot</a></div><div style="box-sizing: border-box; padding: 20px 0px 0px 0px; display: inline-block; border-top: 1px none grey; width: 100%;"><div>This project contains the following files (right-click files you'd like to download):</div><a oncontextmenu="onMouseDownCodeCtxt(this, &quot;code/upload/bezier-curves-surfaces/teapot.cpp&quot;)" style="display: inline-block; margin: 10px 10px 10px 0px; color: rgb(50, 100, 200);" href="http://www.scratchapixel.com/code.php?id=35&amp;origin=/lessons/advanced-rendering/bezier-curve-rendering-utah-teapot&amp;src=0">teapot.cpp</a><a oncontextmenu="onMouseDownCodeCtxt(this, &quot;code/upload/bezier-curves-surfaces/teapotdata.h&quot;)" style="display: inline-block; margin: 10px 10px 10px 0px; color: rgb(50, 100, 200);" href="http://www.scratchapixel.com/code.php?id=35&amp;origin=/lessons/advanced-rendering/bezier-curve-rendering-utah-teapot&amp;src=1">teapotdata.h</a><a oncontextmenu="onMouseDownCodeCtxt(this, &quot;code/upload/bezier-curves-surfaces/geometry.h&quot;)" style="display: inline-block; margin: 10px 10px 10px 0px; color: rgb(50, 100, 200);" href="http://www.scratchapixel.com/code.php?id=35&amp;origin=/lessons/advanced-rendering/bezier-curve-rendering-utah-teapot&amp;src=2">geometry.h</a></div><div name="code" class="code"><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">This program generate and render the Utah teapot
</div><div style="padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(200, 230, 201);">Instructions to compile this program:<br>Download the raytracetransform.cpp, geometry.h and teapot.geo file to a folder. Open a shell/terminal, and run the following command where the files are saved:
c++ -std=c++11 -o teapot -O3 teapot.cpp
Run with: ./shading. Open the file ./out.png in Photoshop or any program reading PPM files.
</div><div></div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">029<br>030<br>031<br>032<br>033<br>034<br>035<br>036<br>037<br>038<br>039<br>040<br>041<br>042<br>043<br>044<br>045<br>046<br>047<br>048<br>049<br>050<br>051<br>052<br>053<br>054<br>055<br>056<br>057<br>058<br>059<br>060<br>061<br>062<br>063<br>064<br>065<br>066<br>067<br>068<br>069<br>070<br>071<br>072<br>073<br>074<br>075<br>076<br>077<br>078<br>079<br>080<br>081<br>082<br>083<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">#include &lt;cstdio&gt; <br>#include &lt;cstdlib&gt; <br>#include &lt;memory&gt; <br>#include &lt;vector&gt; <br>#include &lt;utility&gt; <br>#include &lt;cstdint&gt; <br>#include &lt;iostream&gt; <br>#include &lt;fstream&gt; <br>#include &lt;cmath&gt; <br>#include &lt;sstream&gt; <br>#include &lt;chrono&gt; <br> <br>#include &lt;random&gt; <br> <br>#include "geometry.h" <br>#include "teapotdata.h" <br> <br><span style="color: rgb(100, 100, 100);">// not define on every system</span><br>#ifndef M_PI <br>#define M_PI 3.14159265358979323846  /* pi */ <br>#endif <br> <br>static <b>const</b> <b>float</b> kInfinity = std::numeric_limits&lt;float&gt;::max(); <br>static <b>const</b> <b>float</b> kEpsilon = 1e-8; <br>static <b>const</b> Vec3f kDefaultBackgroundColor = Vec3f(0.235294, 0.67451, 0.843137); <br><b>template</b> &lt;&gt; <b>const</b> Matrix44f Matrix44f::kIdentity = Matrix44f(); <br> <br>inline <br><b>float</b> clamp(<b>const</b> <b>float</b> &amp;lo, <b>const</b> <b>float</b> &amp;hi, <b>const</b> <b>float</b> &amp;v) <br>{ <b>return</b> std::max(lo, std::min(hi, v)); } <br> <br>inline <br><b>float</b> deg2rad(<b>const</b> <b>float</b> &amp;deg) <br>{ <b>return</b> deg * M_PI / 180; } <br> <br>inline <br>Vec3f mix(<b>const</b> Vec3f &amp;a, <b>const</b> Vec3f&amp; b, <b>const</b> <b>float</b> &amp;mixValue) <br>{ <b>return</b> a * (1 - mixValue) + b * mixValue; } <br> <br>struct Options <br>{ <br>    uint32_t width = 640; <br>    uint32_t height = 480; <br>    <b>float</b> fov = 90; <br>    Vec3f backgroundColor = kDefaultBackgroundColor; <br>    Matrix44f cameraToWorld; <br>    <b>float</b> bias = 0.0001; <br>    uint32_t maxDepth = 2; <br>}; <br> <br>enum MaterialType { kDiffuse, kNothing }; <br> <br><b>class</b> Object <br>{ <br> <b>public</b>: <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Setting up the object-to-world and world-to-object matrix </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">089<br>090<br>091<br>092<br>093<br>094<br>095<br>096<br>097<br>098<br>099<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">    Object(<b>const</b> Matrix44f &amp;o2w) : objectToWorld(o2w), worldToObject(o2w.inverse()) {} <br>    virtual ~Object() {} <br>    virtual bool intersect(<b>const</b> Vec3f &amp;, <b>const</b> Vec3f &amp;, <b>float</b> &amp;, uint32_t &amp;, Vec2f &amp;) <b>const</b> = 0; <br>    virtual void getSurfaceProperties(<b>const</b> Vec3f &amp;, <b>const</b> Vec3f &amp;, <b>const</b> uint32_t &amp;, <b>const</b> Vec2f &amp;, Vec3f &amp;, Vec2f &amp;) <b>const</b> = 0; <br>    virtual void displayInfo() <b>const</b> = 0; <br>    Matrix44f objectToWorld, worldToObject; <br>    MaterialType type = kDiffuse; <br>    Vec3f albedo = 0.18; <br>    <b>float</b> Kd = 0.8; // phong model diffuse weight <br>    <b>float</b> Ks = 0.2; // phong model specular weight <br>    <b>float</b> n = 10;   // phong specular exponent <br>    Vec3f BBox[2] = {kInfinity, -kInfinity}; <br>}; <br> <br>bool rayTriangleIntersect( <br>    <b>const</b> Vec3f &amp;orig, <b>const</b> Vec3f &amp;dir, <br>    <b>const</b> Vec3f &amp;v0, <b>const</b> Vec3f &amp;v1, <b>const</b> Vec3f &amp;v2, <br>    <b>float</b> &amp;t, <b>float</b> &amp;u, <b>float</b> &amp;v) <br>{ <br>    Vec3f v0v1 = v1 - v0; <br>    Vec3f v0v2 = v2 - v0; <br>    Vec3f pvec = dir.crossProduct(v0v2); <br>    <b>float</b> det = v0v1.dotProduct(pvec); <br> <br>    <span style="color: rgb(100, 100, 100);">// ray and triangle are parallel if det is close to 0</span><br>    <b>if</b> (fabs(det) &lt; kEpsilon) <b>return</b> false; <br> <br>    <b>float</b> invDet = 1 / det; <br> <br>    Vec3f tvec = orig - v0; <br>    u = tvec.dotProduct(pvec) * invDet; <br>    <b>if</b> (u &lt; 0 || u &gt; 1) <b>return</b> false; <br> <br>    Vec3f qvec = tvec.crossProduct(v0v1); <br>    v = dir.dotProduct(qvec) * invDet; <br>    <b>if</b> (v &lt; 0 || u + v &gt; 1) <b>return</b> false; <br> <br>    t = v0v2.dotProduct(qvec) * invDet; <br> <br>    <b>return</b> (t &gt; 0) ? true : false; <br>} <br> <br><b>class</b> TriangleMesh : <b>public</b> Object <br>{ <br><b>public</b>: <br>    <span style="color: rgb(100, 100, 100);">// Build a triangle mesh from a face index array and a vertex index array</span><br>    TriangleMesh( <br>        <b>const</b> Matrix44f &amp;o2w, <br>        <b>const</b> uint32_t nfaces, <br>        <b>const</b> std::unique_ptr&lt;uint32_t []&gt; &amp;faceIndex, <br>        <b>const</b> std::unique_ptr&lt;uint32_t []&gt; &amp;vertsIndex, <br>        <b>const</b> std::unique_ptr&lt;Vec3f []&gt; &amp;verts, <br>        std::unique_ptr&lt;Vec3f []&gt; &amp;normals, <br>        std::unique_ptr&lt;Vec2f []&gt; &amp;st, <br>        bool singleVertAttr = true) : <br>        Object(o2w), <br>        numTris(0), <br>        isSingleVertAttr(singleVertAttr) <br>    { <br>        uint32_t k = 0, maxVertIndex = 0; <br>        <span style="color: rgb(100, 100, 100);">// find out how many triangles we need to create for this mesh</span><br>        <b>for</b> (uint32_t i = 0; i &lt; nfaces; ++i) { <br>            numTris += faceIndex[i] - 2; <br>            <b>for</b> (uint32_t j = 0; j &lt; faceIndex[i]; ++j) <br>                <b>if</b> (vertsIndex[k + j] &gt; maxVertIndex) <br>                    maxVertIndex = vertsIndex[k + j]; <br>            k += faceIndex[i]; <br>        } <br>        maxVertIndex += 1; <br> <br>        <span style="color: rgb(100, 100, 100);">// allocate memory to store the position of the mesh vertices</span><br>        P = std::unique_ptr&lt;Vec3f []&gt;(new Vec3f[maxVertIndex]); <br>        <b>for</b> (uint32_t i = 0; i &lt; maxVertIndex; ++i) { <br>            objectToWorld.multVecMatrix(verts[i], P[i]); <br>        } <br> <br>        <span style="color: rgb(100, 100, 100);">// allocate memory to store triangle indices</span><br>        trisIndex = std::unique_ptr&lt;uint32_t []&gt;(new uint32_t [numTris * 3]); <br>        Matrix44f transformNormals = worldToObject.transpose(); <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Sometimes we have 1 vertex attribute per vertex per face. So for example of you have 2 quads this would be defefined by 6 vertices but 2 * 4 vertex attribute values for each vertex attribute (normal, tex. coordinates, etc.). But in some cases you may want to have 1 single value per vertex. So in the quad example this would be 6 vertices and 6 vertex attributes values per attribute. We need to provide both option to users. </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>256<br>257<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>272<br>273<br>274<br>275<br>276<br>277<br>278<br>279<br>280<br>281<br>282<br>283<br>284<br>285<br>286<br>287<br>288<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>310<br>311<br>312<br>313<br>314<br>315<br>316<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>324<br>325<br>326<br>327<br>328<br>329<br>330<br>331<br>332<br>333<br>334<br>335<br>336<br>337<br>338<br>339<br>340<br>341<br>342<br>343<br>344<br>345<br>346<br>347<br>348<br>349<br>350<br>351<br>352<br>353<br>354<br>355<br>356<br>357<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">        <b>if</b> (isSingleVertAttr) { <br>            N = std::unique_ptr&lt;Vec3f []&gt;(new Vec3f[maxVertIndex]); <br>            texCoordinates = std::unique_ptr&lt;Vec2f []&gt;(new Vec2f[maxVertIndex]); <br>            <b>for</b> (uint32_t i = 0; i &lt; maxVertIndex; ++i) { <br>                texCoordinates[i] = st[i]; <br>                transformNormals.multDirMatrix(normals[i], N[i]); <br>            } <br>        } <br>        else { <br>            N = std::unique_ptr&lt;Vec3f []&gt;(new Vec3f[numTris * 3]); <br>            texCoordinates = std::unique_ptr&lt;Vec2f []&gt;(new Vec2f[numTris * 3]); <br>            <b>for</b> (uint32_t i = 0, k = 0, l = 0; i &lt; nfaces; ++i) { // <b>for</b> each  face <br>                <b>for</b> (uint32_t j = 0; j &lt; faceIndex[i] - 2; ++j) { <br>                    transformNormals.multDirMatrix(normals[k], N[l]); <br>                    transformNormals.multDirMatrix(normals[k + j + 1], N[l + 1]); <br>                    transformNormals.multDirMatrix(normals[k + j + 2], N[l + 2]); <br>                    N[l].normalize(); <br>                    N[l + 1].normalize(); <br>                    N[l + 2].normalize(); <br>                    texCoordinates[l] = st[k]; <br>                    texCoordinates[l + 1] = st[k + j + 1]; <br>                    texCoordinates[l + 2] = st[k + j + 2]; <br>                } <br>                k += faceIndex[i]; <br>            } <br>        } <br> <br>        <span style="color: rgb(100, 100, 100);">// generate the triangle index array and set normals and st coordinates</span><br>        <b>for</b> (uint32_t i = 0, k = 0, l = 0; i &lt; nfaces; ++i) { // <b>for</b> each  face <br>            <b>for</b> (uint32_t j = 0; j &lt; faceIndex[i] - 2; ++j) { // <b>for</b> each triangle in the face <br>                trisIndex[l] = vertsIndex[k]; <br>                trisIndex[l + 1] = vertsIndex[k + j + 1]; <br>                trisIndex[l + 2] = vertsIndex[k + j + 2]; <br>                l += 3; <br>            } <br>            k += faceIndex[i]; <br>        } <br>    } <br>    <span style="color: rgb(100, 100, 100);">// Test if the ray interesests this triangle mesh</span><br>    bool intersect(<b>const</b> Vec3f &amp;orig, <b>const</b> Vec3f &amp;dir, <b>float</b> &amp;tNear, uint32_t &amp;triIndex, Vec2f &amp;uv) <b>const</b> <br>    { <br>        uint32_t j = 0; <br>        bool isect = false; <br>        <b>for</b> (uint32_t i = 0; i &lt; numTris; ++i) { <br>            <b>const</b> Vec3f &amp;v0 = P[trisIndex[j]]; <br>            <b>const</b> Vec3f &amp;v1 = P[trisIndex[j + 1]]; <br>            <b>const</b> Vec3f &amp;v2 = P[trisIndex[j + 2]]; <br>            <b>float</b> t = kInfinity, u, v; <br>            <b>if</b> (rayTriangleIntersect(orig, dir, v0, v1, v2, t, u, v) &amp;&amp; t &lt; tNear) { <br>              tNear = t; <br>              uv.x = u; <br>              uv.y = v; <br>              triIndex = i; <br>              isect = true; <br>            } <br>            j += 3; <br>        } <br> <br>        <b>return</b> isect; <br>    } <br>    void getSurfaceProperties( <br>        <b>const</b> Vec3f &amp;hitPoint, <br>        <b>const</b> Vec3f &amp;viewDirection, <br>        <b>const</b> uint32_t &amp;triIndex, <br>        <b>const</b> Vec2f &amp;uv, <br>        Vec3f &amp;hitNormal, <br>        Vec2f &amp;hitTextureCoordinates) <b>const</b> <br>    { <br>        uint32_t vai[3]; // vertex attr index <br>        <b>if</b> (isSingleVertAttr) { <br>            vai[0] = trisIndex[triIndex * 3]; <br>            vai[1] = trisIndex[triIndex * 3 + 1]; <br>            vai[2] = trisIndex[triIndex * 3 + 2]; <br>        } <br>        else { <br>            vai[0] = triIndex * 3; <br>            vai[1] = triIndex * 3 + 1; <br>            vai[2] = triIndex * 3 + 2; <br>        } <br>        <b>if</b> (smoothShading) { <br>            <span style="color: rgb(100, 100, 100);">// vertex normal</span><br>            <b>const</b> Vec3f &amp;n0 = N[vai[0]]; <br>            <b>const</b> Vec3f &amp;n1 = N[vai[1]]; <br>            <b>const</b> Vec3f &amp;n2 = N[vai[2]]; <br>            hitNormal = (1 - uv.x - uv.y) * n0 + uv.x * n1 + uv.y * n2; <br>        } <br>        else { <br>            <span style="color: rgb(100, 100, 100);">// face normal</span><br>            <b>const</b> Vec3f &amp;v0 = P[trisIndex[triIndex * 3]]; <br>            <b>const</b> Vec3f &amp;v1 = P[trisIndex[triIndex * 3 + 1]]; <br>            <b>const</b> Vec3f &amp;v2 = P[trisIndex[triIndex * 3 + 2]]; <br>            hitNormal = (v1 - v0).crossProduct(v2 - v0); <br>        } <br> <br>        <span style="color: rgb(100, 100, 100);">// doesn't need to be normalized as the N's are normalized but just for safety</span><br>        hitNormal.normalize(); <br> <br>        <span style="color: rgb(100, 100, 100);">// texture coordinates</span><br>        <b>const</b> Vec2f &amp;st0 = texCoordinates[vai[0]]; <br>        <b>const</b> Vec2f &amp;st1 = texCoordinates[vai[1]]; <br>        <b>const</b> Vec2f &amp;st2 = texCoordinates[vai[2]]; <br>        hitTextureCoordinates = (1 - uv.x - uv.y) * st0 + uv.x * st1 + uv.y * st2; <br>    } <br>    void displayInfo() <b>const</b> <br>    { <br>        std::cerr &lt;&lt; "Number of triangles in this mesh: " &lt;&lt; numTris &lt;&lt; std::endl; <br>        std::cerr &lt;&lt; BBox[0] &lt;&lt; ", " &lt;&lt; BBox[1] &lt;&lt; std::endl; <br>    } <br>    <span style="color: rgb(100, 100, 100);">// member variables</span><br>    uint32_t numTris;                         // number of triangles <br>    std::unique_ptr&lt;Vec3f []&gt; P;              // triangles vertex position <br>    std::unique_ptr&lt;uint32_t []&gt; trisIndex;   // vertex index array <br>    std::unique_ptr&lt;Vec3f []&gt; N;              // triangles vertex normals <br>    std::unique_ptr&lt;Vec2f []&gt; texCoordinates; // triangles texture coordinates <br>    bool smoothShading = true;                // smooth shading by default <br>    bool isSingleVertAttr = true; <br>}; <br> <br><b>class</b> Light <br>{ <br><b>public</b>: <br>    Light(<b>const</b> Matrix44f &amp;l2w, <b>const</b> Vec3f &amp;c = 1, <b>const</b> <b>float</b> &amp;i = 1) : lightToWorld(l2w), color(c), intensity(i) {} <br>    virtual ~Light() {} <br>    virtual void illuminate(<b>const</b> Vec3f &amp;P, Vec3f &amp;, Vec3f &amp;, <b>float</b> &amp;) <b>const</b> = 0; <br>    Vec3f color; <br>    <b>float</b> intensity; <br>    Matrix44f lightToWorld; <br>}; <br> <br>struct IsectInfo <br>{ <br>    <b>const</b> Object *hitObject = nullptr; <br>    <b>float</b> tNear = kInfinity; <br>    Vec2f uv; <br>    uint32_t index = 0; <br>}; <br> <br>bool trace( <br>    <b>const</b> Vec3f &amp;orig, <b>const</b> Vec3f &amp;dir, <br>    <b>const</b> std::vector&lt;std::unique_ptr&lt;Object&gt;&gt; &amp;objects, <br>    IsectInfo &amp;isect) <br>{ <br>    isect.hitObject = nullptr; <br>    <b>for</b> (uint32_t k = 0; k &lt; objects.size(); ++k) { <br>        <b>float</b> tNearTriangle = kInfinity; <br>        uint32_t indexTriangle; <br>        Vec2f uvTriangle; <br>        <b>if</b> (objects[k]-&gt;intersect(orig, dir, tNearTriangle, indexTriangle, uvTriangle) &amp;&amp; tNearTriangle &lt; isect.tNear) { <br>            isect.hitObject = objects[k].get(); <br>            isect.tNear = tNearTriangle; <br>            isect.index = indexTriangle; <br>            isect.uv = uvTriangle; <br>        } <br>    } <br> <br>    <b>return</b> (isect.hitObject != nullptr); <br>} <br> <br>Vec3f castRay( <br>    <b>const</b> Vec3f &amp;orig, <b>const</b> Vec3f &amp;dir, <br>    <b>const</b> std::vector&lt;std::unique_ptr&lt;Object&gt;&gt; &amp;objects, <br>    <b>const</b> std::vector&lt;std::unique_ptr&lt;Light&gt;&gt; &amp;lights, <br>    <b>const</b> Options &amp;options, <br>    <b>const</b> uint32_t &amp; depth = 0) <br>{ <br>    <b>if</b> (depth &gt; options.maxDepth) <b>return</b> 0; <br>    Vec3f hitColor = 0; <br>    IsectInfo isect; <br>    <b>if</b> (trace(orig, dir, objects, isect)) { <br>        Vec3f hitPoint = orig + dir * isect.tNear; <br>        Vec3f hitNormal; <br>        Vec2f hitTexCoordinates; <br>        isect.hitObject-&gt;getSurfaceProperties(hitPoint, dir, isect.index, isect.uv, hitNormal, hitTexCoordinates); <br> <br>        hitColor = std::max(0.f, -hitNormal.dotProduct(dir)) ;//* Vec3f(hitTexCoordinates.x, hitTexCoordinates.y, 1); <br>    } <br>    else { <br>        hitColor = 0.3; <br>    } <br> <br>    <b>return</b> hitColor; <br>} <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">The main render function. This where we iterate over all pixels in the image, generate primary rays and cast these rays into the scene. The content of the framebuffer is saved to a file. </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">363<br>364<br>365<br>366<br>367<br>368<br>369<br>370<br>371<br>372<br>373<br>374<br>375<br>376<br>377<br>378<br>379<br>380<br>381<br>382<br>383<br>384<br>385<br>386<br>387<br>388<br>389<br>390<br>391<br>392<br>393<br>394<br>395<br>396<br>397<br>398<br>399<br>400<br>401<br>402<br>403<br>404<br>405<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">void render( <br>    <b>const</b> Options &amp;options, <br>    <b>const</b> std::vector&lt;std::unique_ptr&lt;Object&gt;&gt; &amp;objects, <br>    <b>const</b> std::vector&lt;std::unique_ptr&lt;Light&gt;&gt; &amp;lights) <br>{ <br>    Vec3f *framebuffer  = new Vec3f[options.width * options.height]; <br>    Vec3f *pix = framebuffer; <br>    <b>float</b> scale = tan(deg2rad(options.fov * 0.5)); <br>    <b>float</b> imageAspectRatio = options.width / (float)options.height; <br>    Vec3f orig; <br>    options.cameraToWorld.multVecMatrix(Vec3f(0), orig); <br>    auto timeStart = std::chrono::high_resolution_clock::now(); <br>    <b>for</b> (uint32_t j = 0; j &lt; options.height; ++j) { <br>        <b>for</b> (uint32_t i = 0; i &lt; options.width; ++i) { <br>            <span style="color: rgb(100, 100, 100);">// generate primary ray direction</span><br>            <b>float</b> x = (2 * (i + 0.5) / (float)options.width - 1) * imageAspectRatio * scale; <br>            <b>float</b> y = (1 - 2 * (j + 0.5) / (float)options.height) * scale; <br>            Vec3f dir; <br>            options.cameraToWorld.multDirMatrix(Vec3f(x, y, -1), dir); <br>            dir.normalize(); <br>            *(pix++) = castRay(orig, dir, objects, lights, options); <br>        } <br>        fprintf(stderr, "\r%3d%c", uint32_t(j / (float)options.height * 100), '%'); <br>    } <br>    auto timeEnd = std::chrono::high_resolution_clock::now(); <br>    auto passedTime = std::chrono::duration&lt;double, std::milli&gt;(timeEnd - timeStart).count(); <br>    fprintf(stderr, "\rDone: %.2f (sec)\n", passedTime / 1000); <br> <br>    <span style="color: rgb(100, 100, 100);">// save framebuffer to file</span><br>    <b>float</b> gamma = 1; <br>    std::ofstream ofs; <br>    ofs.open("out.ppm"); <br>    ofs &lt;&lt; "P6\n" &lt;&lt; options.width &lt;&lt; " " &lt;&lt; options.height &lt;&lt; "\n255\n"; <br>    <b>for</b> (uint32_t i = 0; i &lt; options.height * options.width; ++i) { <br>        <b>char</b> r = (char)(255 * clamp(0, 1, powf(framebuffer[i].x, 1 / gamma))); <br>        <b>char</b> g = (char)(255 * clamp(0, 1, powf(framebuffer[i].y, 1 / gamma))); <br>        <b>char</b> b = (char)(255 * clamp(0, 1, powf(framebuffer[i].z, 1 / gamma))); <br>        ofs &lt;&lt; r &lt;&lt; g &lt;&lt; b; <br>    } <br>    ofs.close(); <br>    delete [] framebuffer; <br>} <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Compute the position of a point along a Bezier curve at t [0:1] </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">409<br>410<br>411<br>412<br>413<br>414<br>415<br>416<br>417<br>418<br>419<br>420<br>421<br>422<br>423<br>424<br>425<br>426<br>427<br>428<br>429<br>430<br>431<br>432<br>433<br>434<br>435<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">Vec3f evalBezierCurve(<b>const</b> Vec3f *P, <b>const</b> <b>float</b> &amp;t) <br>{ <br>    <b>float</b> b0 = (1 - t) * (1 - t) * (1 - t); <br>    <b>float</b> b1 = 3 * t * (1 - t) * (1 - t); <br>    <b>float</b> b2 = 3 * t * t * (1 - t); <br>    <b>float</b> b3 = t * t * t; <br> <br>    <b>return</b> P[0] * b0 + P[1] * b1 + P[2] * b2 + P[3] * b3; <br>} <br> <br>Vec3f evalBezierPatch(<b>const</b> Vec3f *controlPoints, <b>const</b> <b>float</b> &amp;u, <b>const</b> <b>float</b> &amp;v) <br>{ <br>    Vec3f uCurve[4]; <br>    <b>for</b> (<b>int</b> i = 0; i &lt; 4; ++i) <br>        uCurve[i] = evalBezierCurve(controlPoints + 4 * i, u); <br> <br>    <b>return</b> evalBezierCurve(uCurve, v); <br>} <br> <br>Vec3f derivBezier(<b>const</b> Vec3f *P, <b>const</b> <b>float</b> &amp;t) <br>{ <br>    <b>return</b> -3 * (1 - t) * (1 - t) * P[0] + <br>        (3 * (1 - t) * (1 - t) - 6 * t * (1 - t)) * P[1] + <br>        (6 * t * (1 - t) - 3 * t * t) * P[2] + <br>        3 * t * t * P[3]; <br>} <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Compute the derivative of a point on Bezier patch along the u parametric direction </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">439<br>440<br>441<br>442<br>443<br>444<br>445<br>446<br>447<br>448<br>449<br>450<br>451<br>452<br>453<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">Vec3f dUBezier(<b>const</b> Vec3f *controlPoints, <b>const</b> <b>float</b> &amp;u, <b>const</b> <b>float</b> &amp;v) <br>{ <br>    Vec3f P[4]; <br>    Vec3f vCurve[4]; <br>    <b>for</b> (<b>int</b> i = 0; i &lt; 4; ++i) { <br>        P[0] = controlPoints[i]; <br>        P[1] = controlPoints[4 + i]; <br>        P[2] = controlPoints[8 + i]; <br>        P[3] = controlPoints[12 + i]; <br>        vCurve[i] = evalBezierCurve(P, v); <br>    } <br> <br>    <b>return</b> derivBezier(vCurve, u); <br>} <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Compute the derivative of a point on Bezier patch along the v parametric direction </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">457<br>458<br>459<br>460<br>461<br>462<br>463<br>464<br>465<br>466<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">Vec3f dVBezier(<b>const</b> Vec3f *controlPoints, <b>const</b> <b>float</b> &amp;u, <b>const</b> <b>float</b> &amp;v) <br>{ <br>    Vec3f uCurve[4]; <br>    <b>for</b> (<b>int</b> i = 0; i &lt; 4; ++i) { <br>        uCurve[i] = evalBezierCurve(controlPoints + 4 * i, u); <br>    } <br> <br>    <b>return</b> derivBezier(uCurve, v); <br>} <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Generate a poly-mesh Utah teapot out of Bezier patches </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">470<br>471<br>472<br>473<br>474<br>475<br>476<br>477<br>478<br>479<br>480<br>481<br>482<br>483<br>484<br>485<br>486<br>487<br>488<br>489<br>490<br>491<br>492<br>493<br>494<br>495<br>496<br>497<br>498<br>499<br>500<br>501<br>502<br>503<br>504<br>505<br>506<br>507<br>508<br>509<br>510<br>511<br>512<br>513<br>514<br>515<br>516<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">void createPolyTeapot(<b>const</b> Matrix44f&amp; o2w, std::vector&lt;std::unique_ptr&lt;Object&gt;&gt; &amp;objects) <br>{ <br>    uint32_t divs = 8; <br>    std::unique_ptr&lt;Vec3f []&gt; P(new Vec3f[(divs + 1) * (divs + 1)]); <br>    std::unique_ptr&lt;uint32_t []&gt; nvertices(new uint32_t[divs * divs]); <br>    std::unique_ptr&lt;uint32_t []&gt; vertices(new uint32_t[divs * divs * 4]); <br>    std::unique_ptr&lt;Vec3f []&gt; N(new Vec3f[(divs + 1) * (divs + 1)]); <br>    std::unique_ptr&lt;Vec2f []&gt; st(new Vec2f[(divs + 1) * (divs + 1)]); <br> <br>    <span style="color: rgb(100, 100, 100);">// face connectivity - all patches are subdivided the same way so there</span><br>    <span style="color: rgb(100, 100, 100);">// share the same topology and uvs</span><br>    <b>for</b> (uint16_t j = 0, k = 0; j &lt; divs; ++j) { <br>        <b>for</b> (uint16_t i = 0; i &lt; divs; ++i, ++k) { <br>            nvertices[k] = 4; <br>            vertices[k * 4    ] = (divs + 1) * j + i; <br>            vertices[k * 4 + 1] = (divs + 1) * j + i + 1; <br>            vertices[k * 4 + 2] = (divs + 1) * (j + 1) + i + 1; <br>            vertices[k * 4 + 3] = (divs + 1) * (j + 1) + i; <br>        } <br>    } <br> <br>    Vec3f controlPoints[16]; <br>    <b>for</b> (<b>int</b> np = 0; np &lt; kTeapotNumPatches; ++np) { // kTeapotNumPatches <br>        <span style="color: rgb(100, 100, 100);">// set the control points for the current patch</span><br>        <b>for</b> (uint32_t i = 0; i &lt; 16; ++i) <br>            controlPoints[i][0] = teapotVertices[teapotPatches[np][i] - 1][0], <br>            controlPoints[i][1] = teapotVertices[teapotPatches[np][i] - 1][1], <br>            controlPoints[i][2] = teapotVertices[teapotPatches[np][i] - 1][2]; <br> <br>        <span style="color: rgb(100, 100, 100);">// generate grid</span><br>        <b>for</b> (uint16_t j = 0, k = 0; j &lt;= divs; ++j) { <br>            <b>float</b> v = j / (float)divs; <br>            <b>for</b> (uint16_t i = 0; i &lt;= divs; ++i, ++k) { <br>                <b>float</b> u = i / (float)divs; <br>                P[k] = evalBezierPatch(controlPoints, u, v); <br>                Vec3f dU = dUBezier(controlPoints, u, v); <br>                Vec3f dV = dVBezier(controlPoints, u, v); <br>                N[k] = dU.crossProduct(dV).normalize(); <br>                st[k].x = u; <br>                st[k].y = v; <br>            } <br>        } <br> <br>        objects.push_back(std::unique_ptr&lt;TriangleMesh&gt;(new TriangleMesh(o2w, divs * divs, nvertices, vertices, P, N, st))); <br>    } <br>} <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Bezier curve control points </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">520<br>521<br>522<br>523<br>524<br>525<br>526<br>527<br>528<br>529<br>530<br>531<br>532<br>533<br>534<br>535<br>536<br>537<br>538<br>539<br>540<br>541<br>542<br>543<br>544<br>545<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">constexpr uint32_t curveNumPts = 22; <br>Vec3f curveData[curveNumPts] = { <br>    {-0.0029370324, 0.0297554422, 0}, <br>    {-0.1556627219, 0.3293327560, 0}, <br>    {-0.2613958914, 0.9578577085, 0}, <br>    {-0.2555218265, 1.3044275420, 0}, <br>    {-0.2496477615, 1.6509973760, 0}, <br>    {-0.1262923970, 2.0445597290, 0}, <br>    { 0.1791589818, 2.2853963930, 0}, <br>    { 0.4846103605, 2.5262330570, 0}, <br>    { 0.9427874287, 2.2560260680, 0}, <br>    { 1.0132762080, 1.9212043650, 0}, <br>    { 1.0837649880, 1.5863826610, 0}, <br>    { 0.9369133637, 1.2750572170, 0}, <br>    { 0.6667063748, 1.2691831520, 0}, <br>    { 0.3964993859, 1.2633090870, 0}, <br>    { 0.2320255666, 1.3514200620, 0}, <br>    { 0.1850330468, 1.5276420110, 0}, <br>    { 0.1380405269, 1.7038639600, 0}, <br>    { 0.2026552417, 1.8918340400, 0}, <br>    { 0.4082475158, 1.9564487540, 0}, <br>    { 0.6138397900, 2.0210634690, 0}, <br>    { 0.7606914144, 1.8800859100, 0}, <br>    { 0.7606914144, 1.7038639600, 0} <br>}; <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">Generate a thin cylinder centred around a Bezier curve </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">549<br>550<br>551<br>552<br>553<br>554<br>555<br>556<br>557<br>558<br>559<br>560<br>561<br>562<br>563<br>564<br>565<br>566<br>567<br>568<br>569<br>570<br>571<br>572<br>573<br>574<br>575<br>576<br>577<br>578<br>579<br>580<br>581<br>582<br>583<br>584<br>585<br>586<br>587<br>588<br>589<br>590<br>591<br>592<br>593<br>594<br>595<br>596<br>597<br>598<br>599<br>600<br>601<br>602<br>603<br>604<br>605<br>606<br>607<br>608<br>609<br>610<br>611<br>612<br>613<br>614<br>615<br>616<br>617<br>618<br>619<br>620<br>621<br>622<br>623<br>624<br>625<br>626<br>627<br>628<br>629<br>630<br>631<br>632<br>633<br>634<br>635<br>636<br>637<br>638<br>639<br>640<br>641<br>642<br>643<br>644<br>645<br>646<br>647<br>648<br>649<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);">void createCurveGeometry(std::vector&lt;std::unique_ptr&lt;Object&gt;&gt; &amp;objects) <br>{ <br>    uint32_t ndivs = 16; <br>    uint32_t ncurves = 1 + (curveNumPts - 4) / 3; <br>    Vec3f pts[4]; <br>    std::unique_ptr&lt;Vec3f []&gt; P(new Vec3f[(ndivs + 1) * ndivs * ncurves + 1]); <br>    std::unique_ptr&lt;Vec3f []&gt; N(new Vec3f[(ndivs + 1) * ndivs * ncurves + 1]); <br>    std::unique_ptr&lt;Vec2f []&gt; st(new Vec2f[(ndivs + 1) * ndivs * ncurves + 1]); <br>    <b>for</b> (uint32_t i = 0; i &lt; ncurves; ++i) { <br>        <b>for</b> (uint32_t j = 0; j &lt; ndivs; ++j) { <br>            pts[0] = curveData[i * 3]; <br>            pts[1] = curveData[i * 3 + 1]; <br>            pts[2] = curveData[i * 3 + 2]; <br>            pts[3] = curveData[i * 3 + 3]; <br>            <b>float</b> s = j / (float)ndivs; <br>            Vec3f pt = evalBezierCurve(pts, s); <br>            Vec3f tangent = derivBezier(pts, s).normalize(); <br>            bool swap = false; <br> <br>            uint8_t maxAxis; <br>            <b>if</b> (std::abs(tangent.x) &gt; std::abs(tangent.y)) <br>                <b>if</b> (std::abs(tangent.x) &gt; std::abs(tangent.z)) <br>                    maxAxis = 0; <br>                else <br>                    maxAxis = 2; <br>            else <b>if</b> (std::abs(tangent.y) &gt; std::abs(tangent.z)) <br>                    maxAxis = 1; <br>            else <br>                maxAxis = 2; <br> <br>            Vec3f up, forward, right; <br> <br>            switch (maxAxis) { <br>                case 0: <br>                case 1: <br>                    up = tangent; <br>                    forward = Vec3f(0, 0, 1); <br>                    right = up.crossProduct(forward); <br>                    forward = right.crossProduct(up); <br>                    break; <br>                case 2: <br>                    up = tangent; <br>                    right = Vec3f(0, 0, 1); <br>                    forward = right.crossProduct(up); <br>                    right = up.crossProduct(forward); <br>                    break; <br>                default: <br>                    break; <br>            }; <br> <br>            <b>float</b> sNormalized = (i * ndivs + j) / float(ndivs * ncurves); <br>            <b>float</b> rad = 0.1 * (1 - sNormalized); <br>            <b>for</b> (uint32_t k = 0; k &lt;= ndivs; ++k) { <br>                <b>float</b> t = k / (float)ndivs; <br>                <b>float</b> theta = t * 2 * M_PI; <br>                Vec3f pc(cos(theta) * rad, 0, sin(theta) * rad); <br>                <b>float</b> x = pc.x * right.x + pc.y * up.x + pc.z * forward.x; <br>                <b>float</b> y = pc.x * right.y + pc.y * up.y + pc.z * forward.y; <br>                <b>float</b> z = pc.x * right.z + pc.y * up.z + pc.z * forward.z; <br>                P[i * (ndivs + 1) * ndivs + j * (ndivs + 1) + k] = Vec3f(pt.x + x, pt.y + y, pt.z + z); <br>                N[i * (ndivs + 1) * ndivs + j * (ndivs + 1) + k] = Vec3f(x, y, z).normalize(); <br>                st[i * (ndivs + 1) * ndivs + j * (ndivs + 1) + k] = Vec2f(sNormalized, t); <br>            } <br>        } <br>    } <br>    P[(ndivs + 1) * ndivs * ncurves] = curveData[curveNumPts - 1]; <br>    N[(ndivs + 1) * ndivs * ncurves] = (curveData[curveNumPts - 2] - curveData[curveNumPts - 1]).normalize(); <br>    st[(ndivs + 1) * ndivs * ncurves] = Vec2f(1, 0.5); <br>    uint32_t numFaces = ndivs * ndivs * ncurves; <br>    std::unique_ptr&lt;uint32_t []&gt; verts(new uint32_t[numFaces]); <br>    <b>for</b> (uint32_t i = 0; i &lt; numFaces; ++i) <br>        verts[i] = (i &lt; (numFaces - ndivs)) ? 4 : 3; <br>    std::unique_ptr&lt;uint32_t []&gt; vertIndices(new uint32_t[ndivs * ndivs * ncurves * 4 + ndivs * 3]); <br>    uint32_t nf = 0, ix = 0; <br>    <b>for</b> (uint32_t k = 0; k &lt; ncurves; ++k) { <br>        <b>for</b> (uint32_t j = 0; j &lt; ndivs; ++j) { <br>            <b>if</b> (k == (ncurves - 1) &amp;&amp; j == (ndivs - 1)) { break; } <br>            <b>for</b> (uint32_t i = 0; i &lt; ndivs; ++i) { <br>                vertIndices[ix] = nf; <br>                vertIndices[ix + 1] = nf + (ndivs + 1); <br>                vertIndices[ix + 2] = nf + (ndivs + 1) + 1; <br>                vertIndices[ix + 3] = nf + 1; <br>                ix += 4; <br>                ++nf; <br>            } <br>            nf++; <br>        } <br>    } <br> <br>    <b>for</b> (uint32_t i = 0; i &lt; ndivs; ++i) { <br>        vertIndices[ix] = nf; <br>        vertIndices[ix + 1] = (ndivs + 1) * ndivs * ncurves; <br>        vertIndices[ix + 2] = nf + 1; <br>        ix += 3; <br>        nf++; <br>    } <br> <br>    objects.push_back(std::unique_ptr&lt;TriangleMesh&gt;(new TriangleMesh(Matrix44f::kIdentity, numFaces, verts, vertIndices, P, N, st))); <br>} <br> <br> <br></div><div style="width: 100%; padding: 10px; white-space: pre-wrap; border-left-width: 8px; border-left-style: none; border-left-color: rgb(73, 139, 234); background-color: rgb(255, 224, 178);">In the main function of the program, we create the scene (create objects and lights) as well as set the options for the render (image widht and height, maximum recursion depth, field-of-view, etc.). We then call the render function(). </div><div style="margin: 0px 10px; display: inline-block; float: left; width: auto; text-align: center; color: rgb(100, 100, 100);">655<br>656<br>657<br>658<br>659<br>660<br>661<br>662<br>663<br>664<br>665<br>666<br>667<br>668<br>669<br>670<br>671<br>672<br>673<br>674<br>675<br>676<br>677<br>678<br>679<br>680<br>681<br>682<br>683<br>684<br></div><div style="border-left-width: 1px; border-left-style: solid; border-left-color: rgb(100, 100, 100); padding-left: 10px; display: inline-block; width: auto; color: rgb(50, 50, 50);"><b>int</b> main(<b>int</b> argc, <b>char</b> **argv) <br>{ <br>    <span style="color: rgb(100, 100, 100);">// loading gemetry</span><br>    std::vector&lt;std::unique_ptr&lt;Object&gt;&gt; objects; <br> <br>    createPolyTeapot(Matrix44f(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1), objects); <br>    <span style="color: rgb(100, 100, 100);">//createCurveGeometry(objects);</span><br> <br>    <span style="color: rgb(100, 100, 100);">// lights</span><br>    std::vector&lt;std::unique_ptr&lt;Light&gt;&gt; lights; <br>    Options options; <br> <br>    <span style="color: rgb(100, 100, 100);">// aliasing example</span><br>    options.fov = 39.89; <br>    options.width = 512; <br>    options.height = 512; <br>    options.maxDepth = 1; <br> <br>    <span style="color: rgb(100, 100, 100);">// to render the teapot</span><br>    options.cameraToWorld = Matrix44f(0.897258, 0, -0.441506, 0, -0.288129, 0.757698, -0.585556, 0, 0.334528, 0.652606, 0.679851, 0, 5.439442, 11.080794, 10.381341, 1); <br> <br>    <span style="color: rgb(100, 100, 100);">// to render the curve as geometry</span><br>    <span style="color: rgb(100, 100, 100);">//options.cameraToWorld = Matrix44f(0.707107, 0, -0.707107, 0, -0.369866, 0.85229, -0.369866, 0, 0.60266, 0.523069, 0.60266, 0, 2.634, 3.178036, 2.262122, 1);</span><br> <br>    <span style="color: rgb(100, 100, 100);">// finally, render</span><br>    render(options, objects, lights); <br> <br>    <b>return</b> 0; <br>} <br> <br></div></div><!-- end of code --></article></div><!-- end of code-column -->


<iframe id="rufous-sandbox" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: none;"></iframe></body></html>